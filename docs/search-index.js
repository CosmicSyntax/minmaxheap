var N=null,E="",T="t",U="u",searchIndex={};
var R=["result"];

searchIndex["minmaxheap"]={"doc":"Binary Heap This crate implements both min and max binary…","i":[[3,"Heap","minmaxheap","This is a struct where the binary heap is stored, along…",N,N],[12,"capacity",E,"Initial size of the vector to allocate when struct is…",0,N],[12,"heap_size",E,"This is the counter for the number of nodes in the heap.…",0,N],[12,"kind",E,"The type of binary heap. Hold a string literal of \"min\" or…",0,N],[11,"new",E,"Creates a new instance of the Heap Struct. There are two…",0,[[["str"],["usize"]],[["str"],[R[0],["heap","str"]],["heap"]]]],[11,"add",E,"Add nodes into the heap. The nodes do not have to be…",0,[[["self"],["i32"]]]],[11,"peak",E,"Return the value in the top node. If min was chosen, this…",0,[[["self"]],[["i32"],["str"],[R[0],["i32","str"]]]]],[11,"invert",E,"Takes the existing heap and inverts it from max to min or…",0,[[["self"]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"to_string",E,E,0,[[["self"]],["string"]]],[11,"try_from",E,E,0,[[[U]],[R[0]]]],[11,"try_into",E,E,0,[[],[R[0]]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,"borrow_mut",E,E,0,[[["self"]],[T]]],[11,"type_id",E,E,0,[[["self"]],["typeid"]]],[11,"fmt",E,E,0,[[["formatter"],["self"]],[R[0]]]]],"p":[[3,"Heap"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);